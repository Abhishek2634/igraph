/* -*- mode: C -*-  */
/*
   IGraph library.
   Copyright (C) 2022  The igraph development team

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
   02110-1301 USA

*/

#include <string.h>  /* memmove */

#include "igraph_error.h"
#include "igraph_memory.h"
#include "igraph_qsort.h"

static igraph_error_t FUNCTION(igraph_i_vector, init_slice)(BASE_VECTOR* start, BASE_VECTOR* end);
static void FUNCTION(igraph_i_vector, destroy_slice)(BASE_VECTOR* start, BASE_VECTOR* end);
static igraph_error_t FUNCTION(igraph_i_vector, expand_if_full)(TYPE(igraph_vector)* v);
static int FUNCTION(igraph_i_vector, sort_ind_cmp)(void *thunk, const void *p1, const void *p2);

igraph_error_t FUNCTION(igraph_vector, init)(TYPE(igraph_vector)* v, igraph_integer_t size) {
    igraph_integer_t alloc_size = size > 0 ? size : 1;
    IGRAPH_ASSERT(size >= 0);
    v->stor_begin = IGRAPH_CALLOC(alloc_size, BASE_VECTOR);
    if (v->stor_begin == 0) {
        IGRAPH_ERROR("cannot init vector list", IGRAPH_ENOMEM);
    }
    v->stor_end = v->stor_begin + alloc_size;
    v->end = v->stor_begin + size;

    IGRAPH_CHECK(FUNCTION(igraph_i_vector, init_slice)(v->stor_begin, v->end));

    return IGRAPH_SUCCESS;
}

void FUNCTION(igraph_vector, destroy)(TYPE(igraph_vector)* v) {
    IGRAPH_ASSERT(v != 0);

    if (v->stor_begin != 0) {
        FUNCTION(igraph_vector, clear)(v);
        IGRAPH_FREE(v->stor_begin);
        v->stor_begin = NULL;
    }
}

igraph_integer_t FUNCTION(igraph_vector, capacity)(const TYPE(igraph_vector)*v) {
    return v->stor_end - v->stor_begin;
}

igraph_error_t FUNCTION(igraph_vector, reserve)(TYPE(igraph_vector)* v, igraph_integer_t capacity) {
    igraph_integer_t current_capacity;
    BASE_VECTOR *tmp;

    IGRAPH_ASSERT(v != NULL);
    IGRAPH_ASSERT(v->stor_begin != NULL);

    current_capacity = FUNCTION(igraph_vector, capacity)(v);

    if (capacity <= current_capacity) {
        return IGRAPH_SUCCESS;
    }

    tmp = IGRAPH_REALLOC(v->stor_begin, capacity, BASE_VECTOR);
    if (tmp == 0) {
        IGRAPH_ERROR("cannot reserve space for vector list", IGRAPH_ENOMEM);
    }

    v->end = tmp + (v->end - v->stor_begin);
    v->stor_begin = tmp;
    v->stor_end = v->stor_begin + capacity;

    return IGRAPH_SUCCESS;
}

igraph_bool_t FUNCTION(igraph_vector, empty)(const TYPE(igraph_vector)* v) {
    IGRAPH_ASSERT(v != NULL);
    IGRAPH_ASSERT(v->stor_begin != NULL);
    return v->stor_begin == v->end;
}

igraph_integer_t FUNCTION(igraph_vector, size)(const TYPE(igraph_vector)* v) {
    IGRAPH_ASSERT(v != NULL);
    IGRAPH_ASSERT(v->stor_begin != NULL);
    return v->end - v->stor_begin;
}

igraph_error_t FUNCTION(igraph_vector, resize)(TYPE(igraph_vector)* v, igraph_integer_t new_size) {
    igraph_integer_t old_size;
    igraph_error_t retval;

    IGRAPH_ASSERT(v != NULL);
    IGRAPH_ASSERT(v->stor_begin != NULL);

    IGRAPH_CHECK(FUNCTION(igraph_vector, reserve)(v, new_size));

    old_size = FUNCTION(igraph_vector, size)(v);

    v->end = v->stor_begin + new_size;

    if (old_size < new_size) {
        retval = FUNCTION(igraph_i_vector, init_slice)(v->stor_begin + old_size, v->end);
        if (retval) {
            /* undo the change in v->end */
            v->end = v->stor_begin + old_size;
            IGRAPH_CHECK(retval);
        }
    } else if (old_size > new_size) {
        FUNCTION(igraph_i_vector, destroy_slice)(v->end, v->stor_begin + old_size);
    }

    return IGRAPH_SUCCESS;
}

void FUNCTION(igraph_vector, clear)(TYPE(igraph_vector)* v) {
    IGRAPH_ASSERT(v != NULL);
    IGRAPH_ASSERT(v->stor_begin != NULL);
    FUNCTION(igraph_i_vector, destroy_slice)(v->stor_begin, v->end);
    v->end = v->stor_begin;
}

igraph_error_t FUNCTION(igraph_vector, push_back) (TYPE(igraph_vector)* v, BASE_VECTOR* e) {
    IGRAPH_CHECK(FUNCTION(igraph_i_vector, expand_if_full)(v));
    *(v->end) = *e;
    v->end += 1;
    return IGRAPH_SUCCESS;
}

BASE_VECTOR* FUNCTION(igraph_vector, get)(const TYPE(igraph_vector)* v, igraph_integer_t pos) {
    IGRAPH_ASSERT(v != NULL);
    IGRAPH_ASSERT(v->stor_begin != NULL);
    return v->stor_begin + pos;
}

void FUNCTION(igraph_vector, replace)(TYPE(igraph_vector)* v, igraph_integer_t pos, BASE_VECTOR* value) {
    BASE_VECTOR old_value = *(FUNCTION(igraph_vector, get)(v, pos));
    FUNCTION(igraph_vector, set)(v, pos, value);
    v->stor_begin[pos] = *value;
    *value = old_value;
}

void FUNCTION(igraph_vector, set)(TYPE(igraph_vector)* v, igraph_integer_t pos, BASE_VECTOR* value) {
    v->stor_begin[pos] = *value;
}

BASE_VECTOR* FUNCTION(igraph_vector, tail)(const TYPE(igraph_vector) *v) {
    igraph_integer_t size = FUNCTION(igraph_vector, size)(v);
    return size > 0 ? FUNCTION(igraph_vector, get)(v, size - 1) : 0;
}

void FUNCTION(igraph_vector, discard)(TYPE(igraph_vector)* v, igraph_integer_t index) {
    igraph_integer_t size = FUNCTION(igraph_vector, size)(v);

    if (size > 0) {
        FUNCTION(igraph_i_vector, destroy_slice)(v->stor_begin + index, v->stor_begin + index + 1);
        memmove(v->stor_begin + index, v->stor_begin + index + 1, size - index - 1);
        v->end -= 1;
    }
}

void FUNCTION(igraph_vector, discard_back)(TYPE(igraph_vector)* v) {
    igraph_integer_t size = FUNCTION(igraph_vector, size)(v);
    if (size > 0) {
        FUNCTION(igraph_i_vector, destroy_slice)(v->end - 1, v->end);
        v->end -= 1;
    }
}

void FUNCTION(igraph_vector, discard_fast)(TYPE(igraph_vector)* v, igraph_integer_t index) {
    igraph_integer_t size = FUNCTION(igraph_vector, size)(v);

    if (size > 0) {
        FUNCTION(igraph_i_vector, destroy_slice)(v->stor_begin + index, v->stor_begin + index + 1);
        v->end -= 1;
        v->stor_begin[index] = *(v->end);
    }
}

BASE_VECTOR* FUNCTION(igraph_vector, pop_back)(TYPE(igraph_vector)* v) {
    BASE_VECTOR* tmp = FUNCTION(igraph_vector, tail)(v);
    if (tmp) {
        v->end -= 1;
    }
    return tmp;
}

igraph_error_t FUNCTION(igraph_vector, push_back_copy)(TYPE(igraph_vector)* v, BASE_VECTOR* result) {
    igraph_error_t retval;

    IGRAPH_CHECK(FUNCTION(igraph_i_vector, expand_if_full)(v));
    IGRAPH_CHECK(FUNCTION(igraph_i_vector, init_slice)(v->end, v->end + 1));

    retval = ITEM_FUNCTION(igraph_vector, update)(v->end, result);

    if (retval) {
        FUNCTION(igraph_i_vector, destroy_slice)(v->end, v->end + 1);
        IGRAPH_CHECK(retval);
    }

    v->end += 1;

    return IGRAPH_SUCCESS;
}

igraph_error_t FUNCTION(igraph_vector, push_back_new)(TYPE(igraph_vector)* v, BASE_VECTOR** result) {
    IGRAPH_CHECK(FUNCTION(igraph_i_vector, expand_if_full)(v));
    IGRAPH_CHECK(FUNCTION(igraph_i_vector, init_slice)(v->end, v->end + 1));
    *result = v->end;
    v->end += 1;
    return IGRAPH_SUCCESS;
}

igraph_error_t FUNCTION(igraph_vector, remove)(TYPE(igraph_vector)* v, igraph_integer_t index, BASE_VECTOR* result) {
    igraph_integer_t size = FUNCTION(igraph_vector, size)(v);

    IGRAPH_ASSERT(result != 0);

    if (size <= 0) {
        IGRAPH_ERROR("vector list is already empty", IGRAPH_EINVAL);
    }
    if (index < 0 || index >= size) {
        IGRAPH_ERROR("invalid index when removing item", IGRAPH_EINVAL);
    }

    *result = *(FUNCTION(igraph_vector, get)(v, index));

    memmove(v->stor_begin + index, v->stor_begin + index + 1, size - index - 1);
    v->end -= 1;

    return IGRAPH_SUCCESS;
}

igraph_error_t FUNCTION(igraph_vector, remove_fast)(TYPE(igraph_vector)* v, igraph_integer_t index, BASE_VECTOR* result) {
    igraph_integer_t size = FUNCTION(igraph_vector, size)(v);

    IGRAPH_ASSERT(result != 0);

    if (size <= 0) {
        IGRAPH_ERROR("vector list is already empty", IGRAPH_EINVAL);
    }
    if (index < 0 || index >= size) {
        IGRAPH_ERROR("invalid index when removing item", IGRAPH_EINVAL);
    }

    *result = *(FUNCTION(igraph_vector, get)(v, index));

    v->end -= 1;
    v->stor_begin[index] = *(v->end);

    return IGRAPH_SUCCESS;
}

igraph_error_t FUNCTION(igraph_vector, permute)(TYPE(igraph_vector)* v, const igraph_vector_int_t* index) {
    BASE_VECTOR* work;
    igraph_integer_t i, size;

    IGRAPH_ASSERT(v != NULL);
    IGRAPH_ASSERT(v->stor_begin != NULL);
    IGRAPH_ASSERT(index != NULL);
    IGRAPH_ASSERT(index->stor_begin != NULL);

    size = igraph_vector_int_size(index);
    IGRAPH_ASSERT(FUNCTION(igraph_vector, size)(v) == size);

    work = IGRAPH_CALLOC(size, BASE_VECTOR);
    if (work == 0) {
        IGRAPH_ERROR("cannot permute vector list", IGRAPH_ENOMEM);
    }

    for (i = 0; i < size; i++) {
        work[i] = v->stor_begin[VECTOR(*index)[i]];
    }

    memcpy(v->stor_begin, work, sizeof(BASE_VECTOR) * size);

    igraph_Free(work);

    return IGRAPH_SUCCESS;
}

void FUNCTION(igraph_vector, sort)(TYPE(igraph_vector) *v, int (*cmp)(const BASE_VECTOR*, const BASE_VECTOR*)) {
    IGRAPH_ASSERT(v != NULL);
    IGRAPH_ASSERT(v->stor_begin != NULL);
    igraph_qsort(
        v->stor_begin, FUNCTION(igraph_vector, size)(v), sizeof(BASE_VECTOR),
        (int(*)(const void*, const void*))cmp
    );
}

igraph_error_t FUNCTION(igraph_vector, sort_ind)(
    TYPE(igraph_vector) *v, igraph_vector_int_t *inds,
    int (*cmp)(const BASE_VECTOR*, const BASE_VECTOR*)
) {
    igraph_integer_t i, n = FUNCTION(igraph_vector, size)(v);
    BASE_VECTOR **vind, *first;

    IGRAPH_CHECK(igraph_vector_int_resize(inds, n));
    if (n == 0) {
        return IGRAPH_SUCCESS;
    }

    vind = IGRAPH_CALLOC(n, BASE_VECTOR*);
    if (vind == 0) {
        IGRAPH_ERROR("igraph_vector_list_sort_ind failed", IGRAPH_ENOMEM);
    }
    for (i = 0; i < n; i++) {
        vind[i] = v->stor_begin + i;
    }
    first = vind[0];
    igraph_qsort_r(
        vind, n, sizeof(BASE_VECTOR*), (void*) cmp,
        (int(*)(void*, const void*, const void*)) FUNCTION(igraph_i_vector, sort_ind_cmp)
    );
    for (i = 0; i < n; i++) {
        VECTOR(*inds)[i] = vind[i] - first;
    }
    IGRAPH_FREE(vind);

    return IGRAPH_SUCCESS;
}

/* ************************************************************************ */

static igraph_error_t FUNCTION(igraph_i_vector, init_slice)(BASE_VECTOR* start, BASE_VECTOR* end) {
    BASE_VECTOR* current;
    igraph_error_t retval;

    for (current = start; current < end; current++) {
        retval = ITEM_FUNCTION(igraph_vector, init)(current, 0);
        if (retval) {
            FUNCTION(igraph_i_vector, destroy_slice)(start, current);
            IGRAPH_CHECK(retval);
        }
    }

    return IGRAPH_SUCCESS;
}

static void FUNCTION(igraph_i_vector, destroy_slice)(BASE_VECTOR* start, BASE_VECTOR* end) {
    for (; start < end; start++) {
        ITEM_FUNCTION(igraph_vector, destroy)(start);
    }
}

/**
 * Ensures that the vector has at least one extra slot at the end of its
 * allocated storage area.
 */
static igraph_error_t FUNCTION(igraph_i_vector, expand_if_full)(TYPE(igraph_vector)* v) {
    IGRAPH_ASSERT(v != NULL);
    IGRAPH_ASSERT(v->stor_begin != NULL);

    if (v->stor_end == v->end) {
        igraph_integer_t old_size = FUNCTION(igraph_vector, size)(v);
        igraph_integer_t new_size = old_size < IGRAPH_INTEGER_MAX/2 ? old_size * 2 : IGRAPH_INTEGER_MAX;
        if (old_size == IGRAPH_INTEGER_MAX) {
            IGRAPH_ERROR("Cannot push to vector, already at maximum size.", IGRAPH_EOVERFLOW);
        }
        if (new_size == 0) {
            new_size = 1;
        }
        IGRAPH_CHECK(FUNCTION(igraph_vector, reserve)(v, new_size));
    }

    return IGRAPH_SUCCESS;
}

/**
 * Helper function passed to qsort from  igraph_vector_qsort_ind
 */
static int FUNCTION(igraph_i_vector, sort_ind_cmp)(void *thunk, const void *p1, const void *p2) {
    int (*cmp)(const BASE_VECTOR*, const BASE_VECTOR*) = (int (*)(const BASE_VECTOR*, const BASE_VECTOR*)) thunk;
    BASE_VECTOR **pa = (BASE_VECTOR **) p1;
    BASE_VECTOR **pb = (BASE_VECTOR **) p2;
    return cmp(*pa, *pb);
}
