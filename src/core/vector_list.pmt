/* -*- mode: C -*-  */
/*
   IGraph library.
   Copyright (C) 2022  The igraph development team

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
   02110-1301 USA

*/

#include "igraph_error.h"
#include "igraph_memory.h"
#include "igraph_qsort.h"

static igraph_error_t FUNCTION(igraph_i_vector, init_slice)(
    TYPE(igraph_vector)* v, igraph_integer_t start, igraph_integer_t end
);
static void FUNCTION(igraph_i_vector, destroy_slice)(
    TYPE(igraph_vector)* v, igraph_integer_t start, igraph_integer_t end
);

igraph_error_t FUNCTION(igraph_vector, init)(TYPE(igraph_vector)* v, igraph_integer_t size) {
    igraph_integer_t alloc_size = size > 0 ? size : 1;
    IGRAPH_ASSERT(size >= 0);
    v->stor_begin = IGRAPH_CALLOC(alloc_size, BASE_VECTOR);
    if (v->stor_begin == 0) {
        IGRAPH_ERROR("cannot init vector list", IGRAPH_ENOMEM);
    }
    v->stor_end = v->stor_begin + alloc_size;
    v->end = v->stor_begin + size;

    IGRAPH_CHECK(FUNCTION(igraph_i_vector, init_slice)(v, 0, size));

    return IGRAPH_SUCCESS;
}

void FUNCTION(igraph_vector, destroy)(TYPE(igraph_vector)* v) {
    IGRAPH_ASSERT(v != 0);

    if (v->stor_begin != 0) {
        FUNCTION(igraph_vector, clear)(v);
        IGRAPH_FREE(v->stor_begin);
        v->stor_begin = NULL;
    }
}

igraph_integer_t FUNCTION(igraph_vector, capacity)(const TYPE(igraph_vector)*v) {
    return v->stor_end - v->stor_begin;
}

igraph_error_t FUNCTION(igraph_vector, reserve)(TYPE(igraph_vector)* v, igraph_integer_t size) {
    igraph_integer_t actual_size = FUNCTION(igraph_vector, size)(v);
    BASE_VECTOR *tmp;
    IGRAPH_ASSERT(v != NULL);
    IGRAPH_ASSERT(v->stor_begin != NULL);

    if (size <= actual_size) {
        return IGRAPH_SUCCESS;
    }

    tmp = IGRAPH_REALLOC(v->stor_begin, size, BASE_VECTOR);
    if (tmp == 0) {
        IGRAPH_ERROR("cannot reserve space for vector list", IGRAPH_ENOMEM);
    }

    v->stor_begin = tmp;
    v->stor_end = v->stor_begin + size;
    v->end = v->stor_begin + actual_size;

    return IGRAPH_SUCCESS;
}

igraph_bool_t FUNCTION(igraph_vector, empty)(const TYPE(igraph_vector)* v) {
    IGRAPH_ASSERT(v != NULL);
    IGRAPH_ASSERT(v->stor_begin != NULL);
    return v->stor_begin == v->end;
}

igraph_integer_t FUNCTION(igraph_vector, size)(const TYPE(igraph_vector)* v) {
    IGRAPH_ASSERT(v != NULL);
    IGRAPH_ASSERT(v->stor_begin != NULL);
    return v->end - v->stor_begin;
}

igraph_error_t FUNCTION(igraph_vector, resize)(TYPE(igraph_vector)* v, igraph_integer_t newsize) {
    igraph_integer_t size;

    IGRAPH_ASSERT(v != NULL);
    IGRAPH_ASSERT(v->stor_begin != NULL);
    IGRAPH_CHECK(FUNCTION(igraph_vector, reserve)(v, newsize));

    size = FUNCTION(igraph_vector, size)(v);

    v->end = v->stor_begin + newsize;

    if (size < newsize) {
        IGRAPH_CHECK(FUNCTION(igraph_i_vector, init_slice)(v, size, newsize));
    } else if (size > newsize) {
        FUNCTION(igraph_i_vector, destroy_slice)(v, newsize, size);
    }

    return IGRAPH_SUCCESS;
}

void FUNCTION(igraph_vector, clear)(TYPE(igraph_vector)* v) {
    IGRAPH_ASSERT(v != NULL);
    IGRAPH_ASSERT(v->stor_begin != NULL);
    FUNCTION(igraph_i_vector, destroy_slice)(v, 0, FUNCTION(igraph_vector, size)(v));
    v->end = v->stor_begin;
}

igraph_error_t FUNCTION(igraph_vector, push_back) (TYPE(igraph_vector)* v, BASE_VECTOR* e) {
    IGRAPH_ASSERT(v != NULL);
    IGRAPH_ASSERT(v->stor_begin != NULL);

    /* full, allocate more storage */
    if (v->stor_end == v->end) {
        igraph_integer_t old_size = FUNCTION(igraph_vector, size)(v);
        igraph_integer_t new_size = old_size < IGRAPH_INTEGER_MAX/2 ? old_size * 2 : IGRAPH_INTEGER_MAX;
        if (old_size == IGRAPH_INTEGER_MAX) {
            IGRAPH_ERROR("Cannot push to vector, already at maximum size.", IGRAPH_EOVERFLOW);
        }
        if (new_size == 0) {
            new_size = 1;
        }
        IGRAPH_CHECK(FUNCTION(igraph_vector, reserve)(v, new_size));
    }

    *(v->end) = *e;
    v->end += 1;

    return IGRAPH_SUCCESS;
}

BASE_VECTOR* FUNCTION(igraph_vector, get)(const TYPE(igraph_vector)* v, igraph_integer_t pos) {
    IGRAPH_ASSERT(v != NULL);
    IGRAPH_ASSERT(v->stor_begin != NULL);
    return v->stor_begin + pos;
}

void FUNCTION(igraph_vector, replace)(TYPE(igraph_vector)* v, igraph_integer_t pos, BASE_VECTOR* value) {
    BASE_VECTOR old_value = *(FUNCTION(igraph_vector, get)(v, pos));
    FUNCTION(igraph_vector, set)(v, pos, value);
    v->stor_begin[pos] = *value;
    *value = old_value;
}

void FUNCTION(igraph_vector, set)(TYPE(igraph_vector)* v, igraph_integer_t pos, BASE_VECTOR* value) {
    v->stor_begin[pos] = *value;
}

BASE_VECTOR* FUNCTION(igraph_vector, tail)(const TYPE(igraph_vector) *v) {
    igraph_integer_t size = FUNCTION(igraph_vector, size)(v);
    return size > 0 ? FUNCTION(igraph_vector, get)(v, size - 1) : 0;
}

BASE_VECTOR* FUNCTION(igraph_vector, pop_back)(TYPE(igraph_vector)* v) {
    BASE_VECTOR* tmp = FUNCTION(igraph_vector, tail)(v);
    if (tmp) {
        v->end -= 1;
    }
    return tmp;
}

igraph_error_t FUNCTION(igraph_vector, push_back_new)(TYPE(igraph_vector)* v, BASE_VECTOR** result) {
    igraph_integer_t size = FUNCTION(igraph_vector, size)(v);
    IGRAPH_CHECK(FUNCTION(igraph_vector, resize)(v, size + 1));
    *result = FUNCTION(igraph_vector, get)(v, size);
    return IGRAPH_SUCCESS;
}

void FUNCTION(igraph_vector, sort)(TYPE(igraph_vector) *v, int (*cmp)(const BASE_VECTOR*, const BASE_VECTOR*)) {
    IGRAPH_ASSERT(v != NULL);
    IGRAPH_ASSERT(v->stor_begin != NULL);
    igraph_qsort(
        v->stor_begin, FUNCTION(igraph_vector, size)(v), sizeof(BASE_VECTOR),
        (int(*)(const void*, const void*))cmp
    );
}

/* ************************************************************************ */

static igraph_error_t FUNCTION(igraph_i_vector, init_slice)(
    TYPE(igraph_vector)* v, igraph_integer_t start, igraph_integer_t end
) {
    igraph_integer_t current;
    igraph_error_t retval;

    for (current = start; current < end; current++) {
        retval = ITEM_FUNCTION(igraph_vector, init)(v->stor_begin + current, 0);

        if (retval) {
            FUNCTION(igraph_i_vector, destroy_slice)(v, start, current);
            IGRAPH_CHECK(retval);
        }
    }

    return IGRAPH_SUCCESS;
}

static void FUNCTION(igraph_i_vector, destroy_slice)(
    TYPE(igraph_vector)* v, igraph_integer_t start, igraph_integer_t end
) {
    for (; start < end; start++) {
        ITEM_FUNCTION(igraph_vector, destroy)(v->stor_begin + start);
    }
}
